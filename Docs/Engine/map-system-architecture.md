# Map System Architecture
## Texture-Based Rendering for 10,000+ Provinces

**ðŸ“Š Implementation Status:** âš ï¸ Partially Implemented (Phase 1 complete, Phases 2-5 in progress)

> **ðŸ“š Architecture Context:** This document consolidates all map system architecture. See [master-architecture-document.md](master-architecture-document.md) for dual-layer architecture overview.

---

## Table of Contents
1. [Architecture Decision & Rationale](#architecture-decision--rationale)
2. [Coordinate Systems](#coordinate-systems)
3. [Implementation Phases](#implementation-phases)
4. [Map Mode System](#map-mode-system)
5. [URP Integration](#urp-integration)

---

## Architecture Decision & Rationale

### The Problem
Traditional approach: Individual GameObjects/meshes per province
- 10,000 provinces = 10,000 draw calls
- Physics colliders for selection
- **Result:** 20 FPS, unacceptable performance

### The Solution: Texture-Based Rendering
**Core Concept:** Provinces are pixels in textures, not GameObjects
- Province data stored in GPU textures
- Single draw call for entire map
- GPU compute shaders for borders and effects
- Texture-based province selection

**Performance:** 200+ FPS with 10,000 provinces

### Key Architecture Principles

**1. Dual-Layer System**
```
CPU (Simulation):   8-byte ProvinceState Ã— 10k = 80KB
GPU (Presentation): Textures + Shaders = 60MB VRAM
```

**2. Texture-Based Everything**
- Province IDs: R16G16 texture
- Ownership: Updated from simulation state
- Borders: Generated by compute shader
- Selection: Texture lookup, not raycasts

**3. Single Draw Call**
- Entire map rendered as one quad
- Fragment shader handles all visual logic
- No mesh generation

---

## Coordinate Systems

### Three Coordinate Spaces

#### 1. Province Space (Topology)
**Purpose:** Gameplay logic, path finding, adjacency
```csharp
Dictionary<ushort, ushort[]> adjacency;  // Province neighbors
```

#### 2. Texture Space (GPU)
**Purpose:** Rendering, selection, borders
```csharp
Texture2D provinceIDTexture;  // 4096Ã—2048 R16G16
// Pixel at UV(0.45, 0.67) = Province ID 1234
```

#### 3. World Space (3D)
**Purpose:** Unit positions, camera, effects
```csharp
Vector2[] provinceCenters;  // Lookup table: ID â†’ position
```

### Coordinate Transformations

**World â†’ Texture:**
```csharp
public static Vector2 WorldToUV(Vector3 worldPos) {
    return new Vector2(
        worldPos.x / WORLD_WIDTH,
        worldPos.z / WORLD_HEIGHT
    );
}
```

**Texture â†’ Province ID:**
```csharp
public static ushort GetProvinceAt(Vector2 uv) {
    Color32 pixel = provinceIDTexture.GetPixelBilinear(uv.x, uv.y);
    return (ushort)(pixel.r | (pixel.g << 8));
}
```

**Province ID â†’ World Position:**
```csharp
public static Vector3 GetProvinceCenter(ushort id) {
    return provinceCenters[id];  // Lookup table
}
```

### Architecture Decision: Position as Cold Data

**NOT stored in ProvinceState (hot data):**
```csharp
// 8 bytes - no position!
public struct ProvinceState {
    public ushort ownerID;
    public ushort controllerID;
    public byte development;
    public byte terrain;
    public byte fortLevel;
    public byte flags;
}
```

**Stored separately (cold data):**
```csharp
public class ProvinceSpatialData {
    public Vector2[] centers;        // 80KB for 10k provinces
    public Vector2[] labelPositions;
    public Vector2[] portPositions;
    public float[] areas;
}
```

**Rationale:**
- Position is presentation, not simulation
- Keeping it separate saves cache space (12 bytes per province)
- Accessed rarely, loaded on-demand

---

## Implementation Phases

### Phase 1: Simulation Layer Foundation âœ…
**Status:** Complete

- [x] 8-byte ProvinceState struct
- [x] NativeArray storage
- [x] Hot/cold data separation
- [x] Bitmap to simulation loader (3925 provinces)
- [x] Province IDâ†’Index mapping
- [x] Command system (IProvinceCommand)

**Current State:** 3925 provinces loaded from bitmap

### Phase 2: GPU Presentation Layer ðŸ”„
**Status:** Partial

#### Complete:
- [x] Province ID texture infrastructure
- [x] Province owner textures
- [x] Color palettes
- [x] Border render textures
- [x] Core map shader (URP)
- [x] Border detection compute shader

#### Pending:
- [ ] Mouseâ†’province selection (async GPU readback)
- [ ] Selection caching
- [ ] Hover effects
- [ ] Delta texture updates
- [ ] Animation system

### Phase 3: Performance Optimization â³
**Status:** Pending

- [ ] Single draw call rendering
- [ ] SRP Batcher optimization
- [ ] Compute shader optimization
- [ ] Memory profiling (target: <100MB)
- [ ] Frame time validation (target: 200+ FPS at 10k provinces)

### Phase 4: Multiplayer Integration ðŸ“‹
**Status:** Future (see Planning/multiplayer-design.md)

- [ ] Deterministic simulation
- [ ] Delta compression
- [ ] Network sync
- [ ] Client prediction

### Phase 5: Advanced Features â³
**Status:** Pending

- [ ] Animated province transfers
- [ ] Visual effects system
- [ ] Day/night cycles
- [ ] Weather effects

---

## Map Mode System

### Architecture

**Challenge:** Display different data visualizations (political, terrain, development, etc.) without performance loss

**Solution:** GPU-based map mode system with data textures

### Map Mode Types

#### Political Map (Default)
- Shows province ownership
- Nation colors
- Border highlighting

#### Terrain Map
- Terrain types (plains, mountains, desert)
- Elevation visualization
- Climate zones

#### Development Map
- Economic development levels
- Heat map visualization
- Color gradient based on values

#### Trade Map
- Trade nodes
- Trade routes
- Trade value visualization

### Implementation Pattern

```csharp
public enum MapMode {
    Political = 0,
    Terrain = 1,
    Development = 2,
    Trade = 3,
    Religion = 4,
    Culture = 5
}
```

**Shader Implementation:**
```hlsl
// Fragment shader
float4 frag(v2f i) : SV_Target {
    // 1. Get province ID
    ushort provinceID = DecodeProvinceID(i.uv);

    // 2. Get province data based on map mode
    float4 color;
    if (_MapMode == 0) {  // Political
        color = GetOwnerColor(provinceID);
    } else if (_MapMode == 1) {  // Terrain
        color = GetTerrainColor(provinceID);
    } else if (_MapMode == 2) {  // Development
        color = GetDevelopmentColor(provinceID);
    }

    // 3. Apply borders
    if (IsBorder(i.uv)) {
        color = lerp(color, float4(0,0,0,1), 0.5);
    }

    return color;
}
```

### Data Textures per Map Mode

```csharp
public class MapModeSystem {
    // Province data textures
    Texture2D provinceOwners;      // R16 - Political mode
    Texture2D provinceTerrain;     // R8 - Terrain mode
    Texture2D provinceDevelopment; // R8 - Development mode
    Texture2D provinceReligion;    // R8 - Religion mode
    Texture2D provinceCulture;     // R8 - Culture mode

    // Color palettes (1D textures)
    Texture2D nationColors;     // 256 nations
    Texture2D terrainColors;    // 32 terrain types
    Texture2D developmentGradient; // Heat map
}
```

### Switching Map Modes

**CPU Side:**
```csharp
public void SetMapMode(MapMode mode) {
    mapMaterial.SetInt("_MapMode", (int)mode);

    // Bind appropriate data texture
    switch (mode) {
        case MapMode.Political:
            mapMaterial.SetTexture("_DataTexture", provinceOwners);
            break;
        case MapMode.Terrain:
            mapMaterial.SetTexture("_DataTexture", provinceTerrain);
            break;
        // ...
    }
}
```

**Performance:** <0.1ms to switch modes (just material property change)

---

## URP Integration

### Shader Development Approaches

#### Option 1: Shader Graph (Prototyping)
**Pros:**
- Visual workflow
- Good for iteration

**Cons:**
- Limited control
- May need custom nodes for province ID decoding

#### Option 2: HLSL with URP Libraries (Production)
**Pros:**
- Full optimization control
- Required for compute shaders
- Better performance

**Recommended:** Start with Shader Graph, migrate to HLSL

### Custom Render Feature

```csharp
public class MapRenderFeature : ScriptableRendererFeature {
    private MapRenderPass mapPass;
    private BorderComputePass borderPass;

    public override void AddRenderPasses(ScriptableRenderer renderer,
                                         ref RenderingData renderingData) {
        renderer.EnqueuePass(borderPass);  // Generate borders
        renderer.EnqueuePass(mapPass);     // Render map
    }
}
```

**Benefits:**
- Precise render order control
- Integration with URP's frame debugger
- Automatic Render Graph optimization (Unity 2023.3+)

### URP Performance Features

**Render Graph (Unity 2023.3+):**
- Auto-optimizes texture operations
- Eliminates redundant passes

**GPU Resident Drawer (Unity 6+):**
- Perfect for single-draw approach
- Further reduces CPU overhead

**Forward+ Rendering:**
- Better for multiple light sources (cities, effects)
- More suitable than Forward for strategy games

### Shader Requirements

```hlsl
// Province ID texture - CRITICAL: Point filtering!
Texture2D<uint2> _ProvinceIDTexture;
SamplerState sampler_point_clamp_ProvinceIDTexture;

// Province data textures
Texture2D<float> _ProvinceOwnerTexture;
Texture2D<float4> _ProvinceColorTexture;

// Compute shader for borders
[numthreads(8,8,1)]
void BorderDetection(uint3 id : SV_DispatchThreadID) {
    uint currentProvince = _ProvinceIDTexture[id.xy].r;
    uint rightProvince = _ProvinceIDTexture[id.xy + uint2(1,0)].r;
    uint downProvince = _ProvinceIDTexture[id.xy + uint2(0,1)].r;

    bool isBorder = (currentProvince != rightProvince) ||
                    (currentProvince != downProvince);

    _BorderTexture[id.xy] = isBorder ? 1.0 : 0.0;
}
```

---

## Memory Architecture

### Memory Budget (10,000 Provinces)

**CPU (Simulation):**
```
ProvinceState[]:    80KB  (8 bytes Ã— 10k)
Adjacency data:    200KB  (average 6 neighbors)
Spatial lookups:    80KB  (province centers)
Total CPU:         360KB
```

**GPU (Presentation):**
```
Province ID texture:     46MB  (4096Ã—2048 R16G16)
Province owner texture:   3MB  (1024Ã—1024 R16)
Province color palette:   1MB  (256Ã—256 RGBA32)
Border texture:           8MB  (4096Ã—2048 R8)
Map mode textures:        5MB  (terrain, dev, etc.)
Total GPU:              ~60MB
```

**Total System:** <100MB âœ…

### Performance Targets

**Frame Time Budget (200 FPS = 5ms):**
```
Map Rendering:      1.0ms (20%)
Simulation:         1.5ms (30%)
UI:                 1.0ms (20%)
Selection:          0.5ms (10%)
Reserve:            1.0ms (20%)
```

**Specific Targets:**
- Province selection: <1ms
- Map mode switch: <0.1ms
- Border generation: <1ms (compute shader)
- Texture update: <5ms (delta updates)

---

## Best Practices

### DO âœ…
- Use point filtering on province ID textures (no interpolation!)
- Cache GPU texture reads (expensive!)
- Single draw call for map rendering
- Compute shaders for border detection
- Separate hot/cold data
- Fixed-size data structures
- Delta updates for texture changes

### DON'T âŒ
- Store positions in ProvinceState hot data
- Read GPU textures every frame
- Use GameObjects for provinces
- Process pixels on CPU
- Dynamic allocations during gameplay
- Multiple draw calls per map
- Texture filtering on ID textures

---

## Related Documents

- [master-architecture-document.md](master-architecture-document.md) - Dual-layer architecture foundation
- [performance-architecture-guide.md](performance-architecture-guide.md) - Performance patterns
- [core-data-access-guide.md](core-data-access-guide.md) - Hot/cold data separation
- [unity-burst-jobs-architecture.md](unity-burst-jobs-architecture.md) - Burst optimization for data loading

---

## Implementation Checklist

### Immediate (Phase 2 Completion)
- [ ] Async province selection system
- [ ] Selection caching (avoid GPU readbacks)
- [ ] Hover effects
- [ ] Delta texture updates
- [ ] Animation system for ownership changes

### Short Term (Phase 3)
- [ ] Single draw call validation
- [ ] Memory profiling at 10k provinces
- [ ] Frame time optimization
- [ ] SRP Batcher compatibility

### Long Term (Phases 4-5)
- [ ] Multiplayer determinism (see Planning/)
- [ ] Visual effects system
- [ ] Advanced map modes
- [ ] Mod support

---

## Performance Validation

To verify the architecture meets targets:

```csharp
[Test]
public void Validate_10000_Provinces_200FPS() {
    LoadProvinces(10000);
    SimulateGameplay(seconds: 60);

    Assert.Less(AverageFrameTime, 5.0f);  // 200 FPS
    Assert.Less(TotalMemory, 100_000_000); // <100MB
    Assert.Less(SelectionTime, 1.0f);      // <1ms
}
```

Run these tests regularly to catch performance regressions early.