# Map System Architecture
## Texture-Based Rendering for High Province Counts

**Implementation Status:** ‚ö†Ô∏è Partially Implemented (Phase 1 complete, Phases 2-5 in progress)

**Recent Update (2025-10-09):** ProvinceState refactored for engine-game separation. Game-specific fields moved to HegemonProvinceData. Position remains in cold data (correct architecture). See phase-3-complete-scenario-loader-bug-fixed.md.

---

## Table of Contents
1. [Architecture Decision & Rationale](#architecture-decision--rationale)
2. [Coordinate Systems](#coordinate-systems)
3. [Implementation Phases](#implementation-phases)
4. [Map Mode System](#map-mode-system)
5. [URP Integration](#urp-integration)

---

## Architecture Decision & Rationale

### The Problem
Traditional approach: Individual GameObjects/meshes per province with physics colliders for selection. Result: Low performance, unacceptable for large province counts.

### The Solution: Texture-Based Rendering
**Core Concept:** Provinces are pixels in textures, not GameObjects
- Province data stored in GPU textures
- Single draw call for entire map
- GPU compute shaders for borders and effects
- Texture-based province selection

**Performance:** High FPS with many provinces

### Key Architecture Principles

**1. Dual-Layer System**
- CPU (Engine): Fixed-size ProvinceState with generic primitives
- CPU (Game): HegemonProvinceData with game-specific mechanics
- GPU (Presentation): Textures + Shaders in VRAM

**2. Texture-Based Everything**
- Province IDs in R16G16 texture
- Ownership updated from simulation state
- Borders generated by compute shader
- Selection via texture lookup

**3. Single Draw Call**
- Entire map rendered as one quad
- Fragment shader handles all visual logic
- No mesh generation required

---

## Coordinate Systems

### Three Coordinate Spaces

#### 1. Province Space (Topology)
**Purpose:** Gameplay logic, path finding, adjacency

#### 2. Texture Space (GPU)
**Purpose:** Rendering, selection, borders
- Pixel at UV coordinates maps to Province ID

#### 3. World Space (3D)
**Purpose:** Unit positions, camera, effects

### Coordinate Transformations

**World ‚Üí Texture:** Convert world position to UV coordinates

**Texture ‚Üí Province ID:** Decode pixel color to province ID

**Province ID ‚Üí World Position:** Lookup table for province centers

### Architecture Decision: Position as Cold Data

**NOT stored in ProvinceState (engine hot data)**:
- Engine layer: Generic primitives only (owner, controller, terrain, gameDataSlot)
- Game layer: Game-specific hot data (development, fortLevel, unrest, population)

**Stored separately (cold data)**:
- Province centers, label positions, port positions, areas
- Accessed rarely, loaded on-demand

**Rationale:**
- Position is presentation, not simulation
- Separation saves cache space
- Maintains clean separation between simulation (hot) and presentation (spatial)

---

## Implementation Phases

### Phase 1: Simulation Layer Foundation ‚úÖ
**Status:** Complete
- Fixed-size ProvinceState struct
- NativeArray storage
- Hot/cold data separation
- Bitmap to simulation loader
- Province ID‚ÜíIndex mapping
- Command system

**Current State:** Provinces loaded from bitmap

### Phase 2: GPU Presentation Layer üîÑ
**Status:** Partial

#### Complete:
- Province ID texture infrastructure
- Province owner textures
- Color palettes
- Border render textures
- Core map shader (URP)
- Border detection compute shader

#### Pending:
- Mouse‚Üíprovince selection (async GPU readback)
- Selection caching
- Hover effects
- Delta texture updates
- Animation system

### Phase 3: Performance Optimization ‚è≥
**Status:** Pending
- Single draw call rendering
- SRP Batcher optimization
- Compute shader optimization
- Memory profiling
- Frame time validation

### Phase 4: Multiplayer Integration üìã
**Status:** Future (see Planning/multiplayer-design.md)
- Deterministic simulation
- Delta compression
- Network sync
- Client prediction

### Phase 5: Advanced Features ‚è≥
**Status:** Pending
- Animated province transfers
- Visual effects system
- Day/night cycles
- Weather effects

---

## Map Mode System

### Architecture

**Challenge:** Display different data visualizations without performance loss

**Solution:** GPU-based map mode system with data textures

### Map Mode Types

#### Political Map (Default)
- Shows province ownership
- Nation colors
- Border highlighting

#### Terrain Map
- Terrain types
- Elevation visualization
- Climate zones

#### Development Map
- Economic development levels
- Heat map visualization
- Color gradient based on values

#### Trade Map
- Trade nodes
- Trade routes
- Trade value visualization

### Implementation Pattern

Map modes defined as enum, shader implementation determines visualization based on mode.

**Shader Implementation Pattern**:
- Get province ID from texture
- Get province data based on current map mode
- Apply colors from appropriate data texture/palette
- Apply borders from border texture

### Data Textures per Map Mode

**Province data textures**:
- Province owners for political mode
- Province terrain for terrain mode
- Province development for development mode
- Province religion for religion mode
- Province culture for culture mode

**Color palettes (1D textures)**:
- Nation colors
- Terrain colors
- Development gradient for heat maps

### Switching Map Modes

**CPU Side:** Set material property for map mode, bind appropriate data texture

**Performance:** Fast mode switching with just material property change

---

## URP Integration

### Shader Development Approaches

#### Option 1: Shader Graph (Prototyping)
**Pros:** Visual workflow, good for iteration
**Cons:** Limited control, may need custom nodes

#### Option 2: HLSL with URP Libraries (Production)
**Pros:** Full optimization control, required for compute shaders, better performance
**Recommended:** Start with Shader Graph, migrate to HLSL

### Custom Render Feature

URP render feature for map rendering:
- Border generation pass
- Map rendering pass
- Precise render order control

**Benefits:**
- Integration with URP's frame debugger
- Automatic Render Graph optimization (Unity 2023.3+)

### URP Performance Features

**Render Graph (Unity 2023.3+):** Auto-optimizes texture operations, eliminates redundant passes

**GPU Resident Drawer (Unity 6+):** Perfect for single-draw approach, reduces CPU overhead

**Forward+ Rendering:** Better for multiple light sources, more suitable than Forward for strategy games

### Shader Requirements

**Critical requirements**:
- Province ID texture with point filtering (no interpolation)
- Province data textures
- Compute shader for border detection with thread groups

---

## Memory Architecture

### Memory Budget

**CPU (Simulation)**:
- ProvinceState array (engine layer)
- HegemonProvinceData array (game layer)
- Adjacency data
- Spatial lookups
- Total: Bounded memory

**GPU (Presentation)**:
- Province ID texture
- Province owner texture
- Province color palette
- Border texture
- Map mode textures
- Total: Bounded VRAM

**Total System:** Strict memory budget

### Performance Targets

**Frame Time Budget**: Allocated budget for rendering, simulation, UI, selection

**Specific Targets**:
- Fast province selection
- Instant map mode switching
- Fast border generation via compute shader
- Efficient texture updates

---

## Best Practices

### DO
- Use point filtering on province ID textures
- Cache GPU texture reads
- Single draw call for map rendering
- Compute shaders for border detection
- Separate hot/cold data
- Fixed-size data structures
- Delta updates for texture changes

### DON'T
- Store positions in ProvinceState hot data
- Read GPU textures every frame
- Use GameObjects for provinces
- Process pixels on CPU
- Dynamic allocations during gameplay
- Multiple draw calls per map
- Texture filtering on ID textures

---

## Related Documents

- [master-architecture-document.md](master-architecture-document.md) - Dual-layer architecture foundation
- [performance-architecture-guide.md](performance-architecture-guide.md) - Performance patterns
- [core-data-access-guide.md](core-data-access-guide.md) - Hot/cold data separation
- [unity-burst-jobs-architecture.md](unity-burst-jobs-architecture.md) - Burst optimization for data loading

---

## Implementation Checklist

### Immediate (Phase 2 Completion)
- Async province selection system
- Selection caching (avoid GPU readbacks)
- Hover effects
- Delta texture updates
- Animation system for ownership changes

### Short Term (Phase 3)
- Single draw call validation
- Memory profiling at scale
- Frame time optimization
- SRP Batcher compatibility

### Long Term (Phases 4-5)
- Multiplayer determinism (see Planning/)
- Visual effects system
- Advanced map modes
- Mod support

---

## Performance Validation

To verify the architecture meets targets, run tests that validate:
- Frame rate at scale
- Total memory usage within budget
- Fast province selection
- Zero allocations during gameplay

Run these tests regularly to catch performance regressions early.

---

*Last Updated: 2025-10-15*
