// Owner Texture Population Compute Shader for Archon Map System
// Populates ProvinceOwnerTexture from province ownership data
// Runs entirely on GPU for maximum performance with 10,000+ provinces
// Architecture: CPU simulation data â†’ GPU texture (dual-layer architecture)

#pragma kernel PopulateOwners

// Input textures
// ProvinceIDTexture is now ARGB32 RenderTexture (RG16 not supported on all platforms)
// Province IDs are encoded in RG channels (low 8 bits in R, high 8 bits in G)
// CHANGED: Use RWTexture2D instead of Texture2D to match UAV binding from PopulateProvinceIDTexture
// This ensures consistent texture state between compute shader dispatches
RWTexture2D<float4> ProvinceIDTexture;  // ARGB32 format - province ID encoded in RG channels

// Input buffers
StructuredBuffer<uint> ProvinceOwnerBuffer;  // Owner ID per province (indexed by province ID)

// Output texture
RWTexture2D<float> ProvinceOwnerTexture;  // RFloat format - owner ID as normalized float (0.0-1.0)

// Map dimensions
uint MapWidth;
uint MapHeight;

// Debug mode - write province IDs instead of owner IDs to verify texture reading
uint DebugWriteProvinceIDs;

// Province ID decoding - extracts from ARGB32 format (RG channels)
uint DecodeProvinceID(float4 encoded)
{
    // Convert from float [0,1] back to uint8 values (RG channels contain province ID)
    uint r = (uint)(encoded.r * 255.0 + 0.5);
    uint g = (uint)(encoded.g * 255.0 + 0.5);

    // Reconstruct 16-bit province ID from RG channels
    // R = low 8 bits, G = high 8 bits
    return (g << 8) | r;
}

// No encoding needed for R16 format - store uint16 directly

// Thread group size - 8x8 = 64 threads per group
// This is optimal for most modern GPUs and matches BorderDetection.compute
[numthreads(8, 8, 1)]
void PopulateOwners(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Read directly from GPU without Y-flip
    // Both ProvinceIDTexture and ProvinceOwnerTexture use same raw GPU coordinates
    // RWTexture2D uses direct indexing, not Load()
    float4 provinceEncoded = ProvinceIDTexture[id.xy];

    uint provinceID = DecodeProvinceID(provinceEncoded);

    // Look up owner ID from buffer
    // Buffer is indexed by province ID, contains owner ID for each province
    uint ownerID = 0;  // Default to unowned

    // Bounds check for buffer access (assuming max 65536 provinces)
    if (provinceID < 65536)
    {
        ownerID = ProvinceOwnerBuffer[provinceID];
    }

    // Write directly to GPU without Y-flip
    uint2 writePos = id.xy;

    if (DebugWriteProvinceIDs > 0)
    {
        // Debug mode: Write province ID instead of owner ID to verify texture reading
        ProvinceOwnerTexture[writePos] = float(provinceID);
    }
    else
    {
        // Normal mode: Write owner ID as raw float (R32_SFloat can store up to 16777216 exactly)
        // BorderDistanceField.compute will read this as: (uint)(value + 0.5)
        ProvinceOwnerTexture[writePos] = float(ownerID);
    }
}