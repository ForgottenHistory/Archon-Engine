// Border Detection Compute Shader for Archon Map System
// Processes province ID texture to detect borders between provinces
// Runs entirely on GPU for maximum performance with 10,000+ provinces

#pragma kernel DetectBorders

// Input textures
Texture2D<float4> ProvinceIDTexture;
SamplerState samplerProvinceIDTexture;

// Output texture
RWTexture2D<float> BorderTexture;

// Map dimensions
uint MapWidth;
uint MapHeight;

// Border thickness (ENGINE LAYER - generic mechanism)
// 0 = thin borders (1px), 1-5 = progressively thicker borders
uint CountryBorderThickness;
uint ProvinceBorderThickness;

// Anti-aliasing (ENGINE LAYER - generic mechanism)
// 0 = no AA (hard edges), 1-2 = smooth AA gradient
float BorderAntiAliasing;

// Province ID decoding - must match the shader exactly
uint DecodeProvinceID(float2 encoded)
{
    // Convert from float [0,1] back to uint16 values
    uint r = (uint)(encoded.r * 255.0 + 0.5);
    uint g = (uint)(encoded.g * 255.0 + 0.5);

    // Reconstruct 16-bit province ID from RG channels
    return (g << 8) | r;
}

// Thread group size - 8x8 = 64 threads per group
// This is optimal for most modern GPUs
[numthreads(8, 8, 1)]
void DetectBorders(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Sample current pixel's province ID
    float2 currentEncoded = ProvinceIDTexture[id.xy].rg;
    uint currentProvince = DecodeProvinceID(currentEncoded);

    // Initialize border detection
    bool isBorder = false;

    // Check right neighbor (if not at edge)
    if (id.x < MapWidth - 1)
    {
        float2 rightEncoded = ProvinceIDTexture[id.xy + int2(1, 0)].rg;
        uint rightProvince = DecodeProvinceID(rightEncoded);

        if (currentProvince != rightProvince)
            isBorder = true;
    }

    // Check bottom neighbor (if not at edge)
    if (id.y < MapHeight - 1)
    {
        float2 bottomEncoded = ProvinceIDTexture[id.xy + int2(0, 1)].rg;
        uint bottomProvince = DecodeProvinceID(bottomEncoded);

        if (currentProvince != bottomProvince)
            isBorder = true;
    }

    // Check left neighbor (if not at edge) - for complete borders
    if (id.x > 0)
    {
        float2 leftEncoded = ProvinceIDTexture[id.xy + int2(-1, 0)].rg;
        uint leftProvince = DecodeProvinceID(leftEncoded);

        if (currentProvince != leftProvince)
            isBorder = true;
    }

    // Check top neighbor (if not at edge) - for complete borders
    if (id.y > 0)
    {
        float2 topEncoded = ProvinceIDTexture[id.xy + int2(0, -1)].rg;
        uint topProvince = DecodeProvinceID(topEncoded);

        if (currentProvince != topProvince)
            isBorder = true;
    }

    // Write result to border texture
    // 1.0 = border pixel, 0.0 = interior pixel
    BorderTexture[id.xy] = isBorder ? 1.0 : 0.0;
}

// Advanced border detection with configurable thickness
// Uses ProvinceBorderThickness for the thickness value
#pragma kernel DetectBordersThick

[numthreads(8, 8, 1)]
void DetectBordersThick(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Sample current pixel's province ID
    float2 currentEncoded = ProvinceIDTexture[id.xy].rg;
    uint currentProvince = DecodeProvinceID(currentEncoded);

    // Check in a radius for different provinces
    float borderStrength = 0.0;
    int checkRadius = (int)ProvinceBorderThickness;
    int totalChecks = 0;

    for (int dy = -checkRadius; dy <= checkRadius; dy++)
    {
        for (int dx = -checkRadius; dx <= checkRadius; dx++)
        {
            // Skip center pixel
            if (dx == 0 && dy == 0)
                continue;

            // Calculate neighbor position
            int2 neighborPos = id.xy + int2(dx, dy);

            // Bounds check
            if (neighborPos.x < 0 || neighborPos.x >= (int)MapWidth ||
                neighborPos.y < 0 || neighborPos.y >= (int)MapHeight)
                continue;

            // Sample neighbor province
            float2 neighborEncoded = ProvinceIDTexture[neighborPos].rg;
            uint neighborProvince = DecodeProvinceID(neighborEncoded);

            // Check if different province
            if (currentProvince != neighborProvince)
            {
                // Calculate distance-based falloff for smoother thick borders
                float distance = length(float2(dx, dy));
                float falloff = 1.0 - (distance / (float)(checkRadius + 1));
                borderStrength = max(borderStrength, falloff);
            }

            totalChecks++;
        }
    }

    // Write result to border texture with strength
    BorderTexture[id.xy] = borderStrength;
}

// Country border detection - only shows borders between different owners
#pragma kernel DetectCountryBorders

Texture2D<float4> ProvinceOwnerTexture;

[numthreads(8, 8, 1)]
void DetectCountryBorders(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Sample current pixel's province and owner
    float2 currentEncoded = ProvinceIDTexture[id.xy].rg;
    uint currentProvince = DecodeProvinceID(currentEncoded);

    // Get owner ID (assuming R16 format, stored in red channel)
    float currentOwnerData = ProvinceOwnerTexture[id.xy].r;
    uint currentOwner = (uint)(currentOwnerData * 255.0 + 0.5);

    // Initialize border detection
    bool isBorder = false;

    // Check all four neighbors
    int2 offsets[4] = { int2(1,0), int2(-1,0), int2(0,1), int2(0,-1) };

    for (int i = 0; i < 4; i++)
    {
        int2 neighborPos = id.xy + offsets[i];

        // Bounds check
        if (neighborPos.x < 0 || neighborPos.x >= (int)MapWidth ||
            neighborPos.y < 0 || neighborPos.y >= (int)MapHeight)
            continue;

        // Get neighbor province
        float2 neighborEncoded = ProvinceIDTexture[neighborPos].rg;
        uint neighborProvince = DecodeProvinceID(neighborEncoded);

        // Different province?
        if (currentProvince != neighborProvince)
        {
            // Get neighbor owner
            float neighborOwnerData = ProvinceOwnerTexture[neighborPos].r;
            uint neighborOwner = (uint)(neighborOwnerData * 255.0 + 0.5);

            // Only mark as border if different owners
            if (currentOwner != neighborOwner)
            {
                isBorder = true;
                break;
            }
        }
    }

    // Write result to border texture
    BorderTexture[id.xy] = isBorder ? 1.0 : 0.0;
}

// ============================================================================
// Dual Border Detection - Generates BOTH province and country borders
// R channel = Country borders (between different owners)
// G channel = Province borders (between same-owner provinces)
// Supports configurable thickness via BorderThickness parameter
// ============================================================================
#pragma kernel DetectDualBorders

RWTexture2D<float2> DualBorderTexture;

[numthreads(8, 8, 1)]
void DetectDualBorders(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Sample current pixel's province and owner
    float2 currentEncoded = ProvinceIDTexture[id.xy].rg;
    uint currentProvince = DecodeProvinceID(currentEncoded);

    // Get owner ID (R16 format, stored in red channel)
    float currentOwnerData = ProvinceOwnerTexture[id.xy].r;
    uint currentOwner = (uint)(currentOwnerData * 65535.0 + 0.5);

    // Initialize border strengths
    float provinceStrength = 0.0;
    float countryStrength = 0.0;

    // Determine search radius for each border type
    int provinceRadius = (int)ProvinceBorderThickness;
    int countryRadius = (int)CountryBorderThickness;

    // Check maximum radius needed (so we only loop once)
    // IMPORTANT: Include AA in radius calculation so AA works with thin borders
    int maxRadius = max(provinceRadius, countryRadius);
    if (BorderAntiAliasing > 0.0)
    {
        maxRadius = max(maxRadius, (int)ceil(BorderAntiAliasing));
    }

    // Fast path: both borders are thin (0) AND no AA
    if (maxRadius == 0)
    {
        // Check all four neighbors (fast path)
        int2 offsets[4] = { int2(1,0), int2(-1,0), int2(0,1), int2(0,-1) };

        for (int i = 0; i < 4; i++)
        {
            int2 neighborPos = id.xy + offsets[i];

            // Bounds check
            if (neighborPos.x < 0 || neighborPos.x >= (int)MapWidth ||
                neighborPos.y < 0 || neighborPos.y >= (int)MapHeight)
                continue;

            // Get neighbor province
            float2 neighborEncoded = ProvinceIDTexture[neighborPos].rg;
            uint neighborProvince = DecodeProvinceID(neighborEncoded);

            // Different province?
            if (currentProvince != neighborProvince)
            {
                provinceStrength = 1.0;

                // Get neighbor owner
                float neighborOwnerData = ProvinceOwnerTexture[neighborPos].r;
                uint neighborOwner = (uint)(neighborOwnerData * 65535.0 + 0.5);

                // Different owner? Mark as country border
                if (currentOwner != neighborOwner)
                {
                    countryStrength = 1.0;
                }
            }
        }
    }
    else
    {
        // Thick borders: check in radius with distance falloff
        // Use separate thickness for country vs province borders
        float minProvinceDistance = 999999.0;
        float minCountryDistance = 999999.0;
        bool hasProvinceBorder = false;
        bool hasCountryBorder = false;

        for (int dy = -maxRadius; dy <= maxRadius; dy++)
        {
            for (int dx = -maxRadius; dx <= maxRadius; dx++)
            {
                // Skip center pixel
                if (dx == 0 && dy == 0)
                    continue;

                // Calculate neighbor position
                int2 neighborPos = id.xy + int2(dx, dy);

                // Bounds check
                if (neighborPos.x < 0 || neighborPos.x >= (int)MapWidth ||
                    neighborPos.y < 0 || neighborPos.y >= (int)MapHeight)
                    continue;

                // Get neighbor province
                float2 neighborEncoded = ProvinceIDTexture[neighborPos].rg;
                uint neighborProvince = DecodeProvinceID(neighborEncoded);

                // Calculate distance once
                float distance = length(float2(dx, dy));

                // Different province? Check if within province border radius
                if (currentProvince != neighborProvince)
                {
                    hasProvinceBorder = true;
                    minProvinceDistance = min(minProvinceDistance, distance);

                    // Get neighbor owner
                    float neighborOwnerData = ProvinceOwnerTexture[neighborPos].r;
                    uint neighborOwner = (uint)(neighborOwnerData * 65535.0 + 0.5);

                    // Different owner?
                    if (currentOwner != neighborOwner)
                    {
                        hasCountryBorder = true;
                        minCountryDistance = min(minCountryDistance, distance);
                    }
                }
            }
        }

        // Calculate province border strength with anti-aliasing
        if (hasProvinceBorder)
        {
            float provinceThreshold = (float)provinceRadius + BorderAntiAliasing;
            if (minProvinceDistance <= provinceThreshold)
            {
                // Apply anti-aliasing: smooth gradient at the edge
                if (BorderAntiAliasing > 0.0)
                {
                    // Smoothstep from full strength to zero over AA distance
                    float aaStart = (float)provinceRadius;
                    float aaEnd = provinceThreshold;
                    provinceStrength = 1.0 - smoothstep(aaStart, aaEnd, minProvinceDistance);
                }
                else
                {
                    // No AA: hard cutoff at thickness
                    provinceStrength = minProvinceDistance <= (float)provinceRadius ? 1.0 : 0.0;
                }
            }
        }

        // Calculate country border strength with anti-aliasing
        if (hasCountryBorder)
        {
            float countryThreshold = (float)countryRadius + BorderAntiAliasing;
            if (minCountryDistance <= countryThreshold)
            {
                // Apply anti-aliasing: smooth gradient at the edge
                if (BorderAntiAliasing > 0.0)
                {
                    // Smoothstep from full strength to zero over AA distance
                    float aaStart = (float)countryRadius;
                    float aaEnd = countryThreshold;
                    countryStrength = 1.0 - smoothstep(aaStart, aaEnd, minCountryDistance);
                }
                else
                {
                    // No AA: hard cutoff at thickness
                    countryStrength = minCountryDistance <= (float)countryRadius ? 1.0 : 0.0;
                }
            }
        }
    }

    // Write results to dual border texture
    // R channel = country borders (0.0-1.0 based on distance)
    // G channel = province borders (0.0-1.0 based on distance)
    DualBorderTexture[id.xy] = float2(countryStrength, provinceStrength);
}

// ============================================================================
// Border Mask Generation - Creates sparse mask for shader-based detection
// Marks pixels that are within 2-3 pixels of ANY border (province or country)
// Output: R8G8B8A8_UNorm texture where R channel: 1.0 = near border, 0.0 = interior
// Uses R8G8B8A8_UNorm for UAV compatibility (R8/R32 can become TYPELESS)
// This enables resolution-independent borders with minimal per-frame cost
// ============================================================================
#pragma kernel GenerateBorderMask

RWTexture2D<float4> BorderMaskTexture; // MUST match R8G8B8A8_UNorm format

[numthreads(8, 8, 1)]
void GenerateBorderMask(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Sample current pixel's province ID
    float2 currentEncoded = ProvinceIDTexture[id.xy].rg;
    uint currentProvince = DecodeProvinceID(currentEncoded);

    // STEP 1: Junction detection - CARDINAL DIRECTIONS ONLY (no diagonals!)
    // True junction = 3+ provinces meeting at a POINT (not just curved border)
    // CRITICAL: Only check 4-way neighbors (up/down/left/right) to avoid diagonal pollution
    uint uniqueNeighbors[4]; // Max 4 cardinal neighbors
    int uniqueCount = 0;

    // Check only cardinal directions (no diagonals!)
    int2 cardinalOffsets[4] = {
        int2(1, 0),   // Right
        int2(-1, 0),  // Left
        int2(0, 1),   // Down
        int2(0, -1)   // Up
    };

    for (int i = 0; i < 4; i++)
    {
        int2 neighborPos = int2(id.xy) + cardinalOffsets[i];

        if (neighborPos.x < 0 || neighborPos.x >= (int)MapWidth ||
            neighborPos.y < 0 || neighborPos.y >= (int)MapHeight)
            continue;

        float2 neighborEncoded = ProvinceIDTexture[neighborPos].rg;
        uint neighborProvince = DecodeProvinceID(neighborEncoded);

        // Only count neighbors DIFFERENT from current pixel
        if (neighborProvince != currentProvince)
        {
            // Add to unique neighbors list and track direction
            bool alreadyCounted = false;
            for (int j = 0; j < uniqueCount; j++)
            {
                if (uniqueNeighbors[j] == neighborProvince)
                {
                    alreadyCounted = true;
                    break;
                }
            }

            if (!alreadyCounted && uniqueCount < 4)
            {
                uniqueNeighbors[uniqueCount] = neighborProvince;
                uniqueCount++;
            }
        }
    }

    // STEP 2: Border detection (1-pixel radius)
    // Mark pixels touching a different province
    bool isBorder = false;
    int searchRadius = 1;

    for (int dy = -searchRadius; dy <= searchRadius; dy++)
    {
        for (int dx = -searchRadius; dx <= searchRadius; dx++)
        {
            if (dx == 0 && dy == 0)
                continue;

            int2 neighborPos = int2(id.xy) + int2(dx, dy);

            if (neighborPos.x < 0 || neighborPos.x >= (int)MapWidth ||
                neighborPos.y < 0 || neighborPos.y >= (int)MapHeight)
                continue;

            float2 neighborEncoded = ProvinceIDTexture[neighborPos].rg;
            uint neighborProvince = DecodeProvinceID(neighborEncoded);

            if (neighborProvince != currentProvince)
            {
                isBorder = true;
                break;
            }
        }

        if (isBorder)
            break;
    }

    // Simple approach: uniqueCount tells us everything we need!
    // 0.0 = interior (no border)
    // 0.5 = regular border (uniqueCount=1, border between 2 provinces)
    // 0.66 = 3-way junction (uniqueCount=2, 3 provinces meet)
    // 0.75 = 4-way junction (uniqueCount=3, 4 provinces meet)
    float maskValue = 0.0;

    if (isBorder)
    {
        if (uniqueCount >= 3)
        {
            maskValue = 0.75; // 4-way junction
        }
        else if (uniqueCount == 2)
        {
            maskValue = 0.66; // 3-way junction
        }
        else // uniqueCount == 1 or 0
        {
            maskValue = 0.5; // Regular border - use 0.5 for perfect bilinear gradients
        }
    }

    BorderMaskTexture[id.xy] = float4(maskValue, 0, 0, 0);
}

// ============================================================================
// Copy BorderTexture to BorderMaskTexture
// Converts smooth curve borders (from BorderTexture) into sparse mask
// BorderTexture contains distance field for smooth curves
// BorderMaskTexture contains 1.0 where borders are close, 0.0 elsewhere
// Note: Must declare BorderTexture locally as float4 (global is float, incorrect)
// ============================================================================
#pragma kernel CopyBorderToMask

// Local texture declarations for this kernel
RWTexture2D<float4> BorderTextureFloat4;   // Actual BorderTexture format (R8G8B8A8)

[numthreads(8, 8, 1)]
void CopyBorderToMask(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Read border classification from BorderTexture
    // BorderTexture.R = province border (1.0 = is border, 0.0 = not border)
    // BorderTexture.G = country border (1.0 = is border, 0.0 = not border)
    float2 borderValues = BorderTextureFloat4[id.xy].rg;

    // Mark as border if EITHER country or province border exists
    // Use threshold 0.1 to catch any non-zero border value
    bool isProvinceBorder = borderValues.r > 0.1;
    bool isCountryBorder = borderValues.g > 0.1;
    bool nearBorder = isProvinceBorder || isCountryBorder;

    // Write to mask: 1.0 = border region, 0.0 = interior
    // This creates sparse mask for shader-based detection
    BorderMaskTexture[id.xy] = float4(nearBorder ? 1.0 : 0.0, 0, 0, 0);
}