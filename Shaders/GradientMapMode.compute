// Gradient Map Mode Compute Shader for Archon Map System
// Colorizes provinces based on gradient values (development, farms, economy, etc.)
// Runs entirely on GPU for maximum performance with 10,000+ provinces
// Architecture: CPU simulation data → GPU colorization → Output texture (dual-layer architecture)
//
// Performance: ~1ms for 11.5M pixels vs 105ms CPU-side processing

#pragma kernel ColorizeGradient

// Input textures
RWTexture2D<float4> ProvinceIDTexture;  // ARGB32 format - province ID encoded in RG channels

// Input buffers
StructuredBuffer<float> ProvinceValueBuffer;  // Value per province (0.0-1.0, already normalized)
StructuredBuffer<float4> GradientColors;      // 3 colors for gradient (low, mid, high)

// Output texture
RWTexture2D<float4> OutputTexture;  // RGBA32 format - colorized output

// Map dimensions
uint MapWidth;
uint MapHeight;

// Gradient configuration
float MinValue;  // Minimum value in dataset
float MaxValue;  // Maximum value in dataset

// Special colors
float4 OceanColor;   // Color for ocean provinces (provinceID = 0)

// Province ID decoding - extracts from ARGB32 format (RG channels)
uint DecodeProvinceID(float4 encoded)
{
    // Convert from float [0,1] back to uint8 values (RG channels contain province ID)
    uint r = (uint)(encoded.r * 255.0 + 0.5);
    uint g = (uint)(encoded.g * 255.0 + 0.5);

    // Reconstruct 16-bit province ID from RG channels
    // R = low 8 bits, G = high 8 bits
    return (g << 8) | r;
}

// Evaluate gradient at normalized position (0.0-1.0)
float4 EvaluateGradient(float t)
{
    // Clamp t to [0,1]
    t = saturate(t);

    // Three-color gradient: lowColor -> midColor -> highColor
    float4 lowColor = GradientColors[0];
    float4 midColor = GradientColors[1];
    float4 highColor = GradientColors[2];

    if (t < 0.5)
    {
        // Interpolate between low and mid
        float localT = t * 2.0; // Remap [0,0.5] to [0,1]
        return lerp(lowColor, midColor, localT);
    }
    else
    {
        // Interpolate between mid and high
        float localT = (t - 0.5) * 2.0; // Remap [0.5,1] to [0,1]
        return lerp(midColor, highColor, localT);
    }
}

// Thread group size - 8x8 = 64 threads per group
// This is optimal for most modern GPUs and matches other compute shaders
[numthreads(8, 8, 1)]
void ColorizeGradient(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= MapWidth || id.y >= MapHeight)
        return;

    // Read province ID from GPU texture
    float4 provinceEncoded = ProvinceIDTexture[id.xy];
    uint provinceID = DecodeProvinceID(provinceEncoded);

    // Default to ocean color
    float4 outputColor = OceanColor;

    // Look up value for this province
    if (provinceID > 0 && provinceID < 65536)
    {
        float value = ProvinceValueBuffer[provinceID];

        // Only colorize if value >= 0 (negative values = skip/invalid/ocean provinces)
        // Note: 0.0 is a valid normalized value (minimum in dataset)
        if (value >= 0.0)
        {
            // Value is already normalized to [0,1] by CPU
            outputColor = EvaluateGradient(value);
        }
    }

    // Write colorized output
    OutputTexture[id.xy] = outputColor;
}
